---
description: "Solidity rules for the contracts"
alwaysApply: true
fileGlobs:
  - "src/**/*.sol"
---

Solidity Guidelines for This Project:

- Organize shared logic and reusable code using `libraries/` (for pure logic) and `interfaces/` (for contract interfaces) directories.
- Explicitly import only what your contract requires; avoid generic imports such as just `forge-std/Test.sol`, prefer targeted imports like `import {Test} from "forge-std/Test.sol";`.
- Avoid unbounded loops, recursive calls, and denial-of-service vectors. Data structures and access patterns should enable O(log n) or better operations on chain.
- All access control should minimize server trust assumptions; privilege via on-chain role management and cryptographic signatures, not off-chain checks.
- For interactions between contracts, always use interfaces. Never rely on external contract internals.
- Use custom errors (not just require strings) for efficiency.
- Prefer immutable and constant state variables for settings that never change.
- Events must be emitted for all critical storage changes, particularly where state needs to be monitored or indexed by off-chain Eigen Compute applications.
- Carefully structure storage to avoid unnecessary on-chain costs; prefer mappings or compact structs.
- EIP-712 domain separators and verification must be implemented where signatures are validated on-chain.
- All user data should be address-, database-, or instance-isolated, reflecting the architecture’s cryptographically owned decentralized data principles.
- All value transfers must use safe transfer patterns (Checks-Effects-Interactions).
- Never hardcode addresses or sensitive information.
- Document all contract roles, privileged functions, and data flows as NatSpec comments.
- Write unit/integration tests for all functionalities with deterministic, replayable contexts. When writing tests, avoid non-determinism in storage or event assertions.
- Favor upgradeable patterns only if audits and upgradability risks are clearly documented.
- If you are trying to use Unicode characters, use a unicode"..." string literal.
- Use screaming snake case for immutable variables and constants.
- **Pay careful attention to rounding errors and loss of precision when using integer division or fixed-point math.** For example, `1e18 / 2e18` equals `0` due to truncation. All arithmetic should be reviewed for potential precision loss, truncation, or rounding—especially for calculations involving fees, shares, rewards, or ratios. When exact precision is critical, apply appropriate scaling and rounding strategies.

Refer to `architecture.mdc` for additional project-specific invariants and constraints around decentralization, instance isolation, storage limits, and security properties.
